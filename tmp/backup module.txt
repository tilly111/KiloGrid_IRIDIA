#include <avr/io.h>
#include <avr/wdt.h>
#include <util/delay.h>     // delay macros
#include <avr/interrupt.h>
#include <math.h>

#include "module.h"
#include "moduleLED.h"
#include "moduleIR.h"
#include "CAN.h"
#include "mcp2515.h"

#include "../communication.h"

// TODO check if this is needed 
// #define MAX_MESSAGE_REPEAT 1  // defines how often a message is maximum repeated - if in the mean time a other message arrives the timer is resetted 
#define MAX_RESET_TIMER 500

typedef enum{
    false = 0,
    true = 1,
} bool;

// internal module memory 
volatile uint8_t cell_x[4] = {0, 0, 0, 0};
volatile uint8_t cell_y[4] = {0, 0, 0, 0};
volatile uint8_t cell_role[4] = {0, 0, 0, 0};
volatile uint8_t cell_colour[4] = {0, 0, 0, 0};

volatile uint8_t cell_received_op[4] = {0, 0, 0, 0};


// iterators .. init here to see if we exceed storage limits!
uint8_t i_it;
uint8_t k_it;
uint8_t l_it;

uint8_t x_it;
uint8_t y_it;
uint8_t cell_it;

// variables for IR_rx
uint8_t tmp_ir_it;
// temporary storage for the IR-messages 
uint8_t tmp_ir_data[4][8];

// variables for CAN_rx
uint8_t cell_can_it;
uint8_t tmp_can_it;
// temporary storage for can messages 
uint8_t tmp_can_data[4][8];

// receive flags initialised to false 
bool 
bool received_ir = false;
bool received_can[4] = {false, false, false, false};


/*-----------------------------------------------------------------------------------------------*/
/* This function is called when the module receives an IR-message. It is a callback, thus can    */ 
/*  called anytime, that is why you should here store temp data and rewrite them in the main 	 */
/*  loop.                                                                           			 */
/*-----------------------------------------------------------------------------------------------*/
void IR_rx(IR_message_t *m, cell_num_t c, distance_measurement_t *d, uint8_t CRC_error) {
	// TODO tracking of the robot does not work at the moment if you want to send user messages 
	//  that is why we command it out here. 
    // if(!CRC_error && m->type == TRACKING){
    //     CAN_message_t* msg = next_CAN_message();
    //     tracking_user_data_t usr_data; 
    //     usr_data.byte[0] = m->data[0];
    //     usr_data.byte[1] = m->data[1];
    //     usr_data.byte[2] = m->data[2];
    //     usr_data.byte[3] = m->data[3];
    //     usr_data.byte[4] = m->data[4];
    //     usr_data.byte[5] = m->data[5]; 
    //     usr_data.byte[6] = m->data[6];
    //     if(msg != NULL) { // if the buffer is not full
    //         serialize_tracking_message(msg, c, &usr_data);
    //     }
    // }else if(!CRC_error && m->type == 11){  // VIRTUAL_AGENT_MSG
    
    if (!CRC_error && m->type == VIRTUAL_AGENT_MSG){  // msg type 11
        // set tmp data to the receiving cell 
        for (tmp_ir_it = 0; tmp_ir_it < 8; tmp_ir_it++){
            tmp_ir_data[c][tmp_ir_it] = m->data[tmp_ir_it];
        }
        // set ir received flag
        received_ir = true;
    }
}


/*-----------------------------------------------------------------------------------------------*/
/* This function is called when the module receives a CAN-message. It is a callback, thus can    */ 
/*  called anytime, that is why you should here store temp data and rewrite them in the main 	 */
/*  loop. Further, we need to check if the module is in range to receive, in order to relief the */ 
/*	netwrok (if we use broadcast to all modules we need one message per robot message and some 	 */
/*	processing, instead if we address every module individually we would need much more messages)*/
/*-----------------------------------------------------------------------------------------------*/
void CAN_rx(CAN_message_t *m) { 
    if (m->data[0] == CAN_MODULE_TO_MODULE){  // user message
    	for (cell_can_it = 0; cell_can_it < 4; cell_can_it++){  // iterate through all cells 
    		// use euclidean distance for checking which cell is in communication range 
    		if (sqrt(pow(fabs(m->data[1] - cell_x[cell_it]), 2) + pow(fabs(m->data[2] - cell_y[cell_it]), 2)) < m->data[3]){
    			// store tmp data
    			for (tmp_can_it = 0; tmp_can_it < 8; tmp_can_it++){
    				tmp_can_data[cell_can_it][tmp_can_it] = m->data[tmp_can_it];
    			}
    			// set can received
        		received_can[cell_can_it] = true;
    		}
    	}
    }
}


/*-----------------------------------------------------------------------------------------------*/
/* This method implements the setup of the Kilogrid, it is called when you press the setup 		 */
/*  button in the Kilogui. It is run iterative for each module. 								 */
/*-----------------------------------------------------------------------------------------------*/
void setup(){
	// read kconf data
    cell_x[0] = (configuration[0] * 2);
    cell_x[1] = (configuration[0] * 2 + 1);
    cell_x[2] = (configuration[0] * 2);
    cell_x[3] = (configuration[0] * 2 + 1);

    cell_y[0] = (configuration[1] * 2 + 1);
    cell_y[1] = (configuration[1] * 2 + 1);
    cell_y[2] = (configuration[1] * 2);
    cell_y[3] = (configuration[1] * 2);

    cell_role[0] = (configuration[2]);
    cell_role[1] = (configuration[2]);
    cell_role[2] = (configuration[2]);
    cell_role[3] = (configuration[2]);

    cell_colour[0] = (configuration[3]);
    cell_colour[1] = (configuration[4]);
    cell_colour[2] = (configuration[5]);
    cell_colour[3] = (configuration[6]);

    // init tmp receive msgs
    for(k_it = 0; k_it < 4; k_it++){
        for(l_it = 0; l_it < 8; l_it++){
            tmp_ir_data[k_it][l_it] = 0;
        }
    }

    // set intial colour - will be reset in the main loop of module.c when starting the experiment
    //  because there first the colour is set to magenta and then resetted (because they want to
    //  start the robots)
    for (i_it = 0; i_it < 4; i_it++){
    	set_LED_with_brightness(cell_id[i_it], WHITE, HIGH);
    }
}


void loop() {
	// send init message: for how long??


    // compute ir msg 
    if (received_ir){
        for(cell_it = 0; cell_it < 4; cell_it++){
            // msg structure: robot_commitment, communication range, robot_x, robot_y, msg_number_sent
            if (tmp_ir_data[cell_it][0] != 0){
                    received_commitment[cell_it] = tmp_ir_data[cell_it][0];
                    received_com_range[cell_it] = tmp_ir_data[cell_it][1];
                    received_robot_x[cell_it] = tmp_ir_data[cell_it][2];
                    received_robot_y[cell_it] = tmp_ir_data[cell_it][3];
                    ir_msg_to_send = true;
                    // forward robot msg 
                    can_msg_to_send = true;
            }
            // clear 
            for(k_it = 0; k_it < 4; k_it++){
                tmp_ir_data[cell_it][k_it] = 0;
            }
        }
    }

    // compute can msg
    // can data structure: flag, x_sender, y_sender, com_range, commitment 
    if (received_can){
        received_can = false;
        for(cell_it = 0; cell_it < 4; cell_it++){
            if (sqrt(pow(fabs(tmp_can_data[1] - cell_x[cell_it]), 2) + pow(fabs(tmp_can_data[2] - cell_y[cell_it]), 2)) < tmp_can_data[3]) {
                ir_msg_to_send = true;
                opt_to_send_ir[cell_it] = tmp_can_data[4];
            } else{
            	opt_to_send_ir[cell_it] = current_colour[cell_it];  // this should be nothing, only called for cells when receiving a can message, and it is not in range
            	
            }
        }
    }

    // set ir msg
    if (ir_msg_to_send){
        ir_msg_to_send = false;
        for (cell_it = 0; cell_it < 4; cell_it++){
            current_colour[cell_it] = opt_to_send_ir[cell_it];
            // TODO: do proper sending of the message, now only colour


        }
    }

    // // set can msg 
    if (can_msg_to_send){
        can_msg_to_send = false;
        for(cell_it = 0; cell_it < 4; cell_it++){
            if (received_commitment[cell_it] != 0){
                init_CAN_message(&tmp_can_msg);
                tmp_can_msg.id = CAN_MODULE_TO_MODULE;  // TODO what does the id do?
                tmp_can_msg.data[0] = CAN_MODULE_TO_MODULE; // message id
                tmp_can_msg.data[1] = received_robot_x[cell_it]; // x sender 
                tmp_can_msg.data[2] = received_robot_y[cell_it]; // y sender 
                tmp_can_msg.data[3] = received_com_range[cell_it]; // range
                tmp_can_msg.data[4] = received_commitment[cell_it]; // commitment 
                tmp_can_msg.data[5] = some_cycle_counter - last_cycle_counter; // debug info
                tmp_can_msg.data[6] = 0;
                tmp_can_msg.data[7] = 0;
                last_cycle_counter = some_cycle_counter;
                
                cell_address.type = ADDR_BROADCAST; // see communication/kilogrid.h for further information
                cell_address.x = 0;  // is the position of a module imo??
                cell_address.y = 0;
                CAN_message_tx(&tmp_can_msg, cell_address); 
                //TODO: set cells of this module as well!!!!!!!
                // reset 
                received_commitment[cell_it] = 0;
            }
        }
    }


    some_cycle_counter += 1; 
    some_send_counter += 1;
    for (i_it = 0; i_it < 4; i_it++){
        if (cell_x[i_it] == 5 && cell_y[i_it] == 20){
            if (some_send_counter % 100 == 0){ //  % 200 == 0
                current_colour[i_it] = (current_colour[i_it] + 1) % 3;
                init_CAN_message(&tmp_can_msg);
                tmp_can_msg.id = current_colour[i_it];  // dont know if id is important - maybe to check if msg arrived twice or so - max 65,535
                tmp_can_msg.data[0] = CAN_MODULE_TO_MODULE; // message id - see CAN_message_type_t @ CAN.h and process_CAN_message @ module.c 
                tmp_can_msg.data[1] = 5; // x sender 
                tmp_can_msg.data[2] = 20; // y sender 
                tmp_can_msg.data[3] = 45 ; // range
                tmp_can_msg.data[4] = current_colour[i_it]; // information
                tmp_can_msg.data[5] = some_cycle_counter - last_cycle_counter; // debug info
                tmp_can_msg.data[6] = 0;
                tmp_can_msg.data[7] = 0;
                last_cycle_counter = some_cycle_counter;
                
                CAN_send_broadcast_message(&tmp_can_msg);

                // for all cells in my module
                current_colour[0] = current_colour[i_it];
                current_colour[1] = current_colour[i_it];
                current_colour[2] = current_colour[i_it];
                current_colour[3] = current_colour[i_it];
            }
        }

    _delay_ms(5);
}


/*-----------------------------------------------------------------------------------------------*/
/* Main method. Called to initalice the module and set callbacks.	 							 */
/*-----------------------------------------------------------------------------------------------*/
int main() {
    module_init();

    // register function callbacks
    module_CAN_message_rx = CAN_rx;

    // TODO check if needed!
    //module_CAN_message_tx_success = CAN_message_tx_success_my;
    //module_CAN_message_tx_success = CAN_tx_success;  // seems not to work

    module_IR_message_rx = IR_rx;

    module_start(setup, loop);

    return 0;
}
